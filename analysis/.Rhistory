for (r in 1:n.genes) {
YtY[r,] <- as.numeric(strsplit(all_data[7+r], split='\t', perl=T)[[1]])
}
sxx <- as.numeric(strsplit(all_data[8+n.genes], split='\t', perl=T)[[1]][2])   #X'X, a scalar
YtX <- as.numeric(strsplit(all_data[10+n.genes], split='\t', perl=T)[[1]])    #Y'X, a vector
suff.stat <- list(SYY = YtY/n.ind, sxx = sxx/n.ind, SYX = YtX/n.ind, SY1 = rep(0, n.genes), mu.g = 0)
if (n.genes <= 15) {
n.iter <- 3000
n.burn <- 1000
} else {
if (n.genes <= 25) {
n.iter <- 4000
n.burn <- 2000
} else {
n.iter <- 5000
n.burn <- 2500
}
}
sigma.a <- c(0.1, 0.4)
weights.sigma <- c(1, 1)
gibbs <- Gibbs.dir(n.iter, n.burn, suff.stat, which(Gene.names == gene), n.ind, sigma.a, weights.sigma, n.genes-1)
PUP.source[count] = gibbs$post.mean[gibbs$D.ind]
gibbs.mat <- rbind(gibbs$post.mean)
colnames(gibbs.mat) <- Gene.names
out.file <- file.path(directory.out, sub("(summary)", '\\1.gibbs', file, perl=T))
write.table(gibbs.mat, out.file, col.names=T, row.names=F, append=F, quote=F, sep="\t")
print(paste0(as.character(count), " of ", as.character(length(all_files))))
count = count + 1
}
plot(N.genes, 1-PUP.source, main='Posterior Probability of Source Gene as a Function of Network Size', xlab='Number of Genes in Network', ylab='Posterior Probability Source Gene is Affected by SNP')
plot(sort(1-PUP.source))
director.in
directory.out
file.path(directory.out, sub("(summary)", '\\1.gibbs', file, perl=T))
gibbs.file = readlines(out.file)
gibbs.file = readLines(out.file)
gibbs.file
file
which(Gene.names == gene)
as.numeric(strsplit(gibbs.file[8], split='\t', perl=T)[[1]])[which(Gene.names == gene)]
which(Gene.names == gene)
run_gibbs = FALSE;   #Whether or not to run the Gibbs sampler. If not, I just look for the file in 'directory.out' to get the necessary information
count
if (run_gibbs) {
gibbs <- Gibbs.dir(n.iter, n.burn, suff.stat, which(Gene.names == gene), n.ind, sigma.a, weights.sigma, n.genes-1)
PUP.source[count] = gibbs$post.mean[gibbs$D.ind]
gibbs.mat <- rbind(gibbs$post.mean)
colnames(gibbs.mat) <- Gene.names
write.table(gibbs.mat, out.file, col.names=T, row.names=F, append=F, quote=F, sep="\t")
} else {
gibbs.file = readLines(out.file)
tmp.pup = as.numeric(strsplit(gibbs.file[8], split='\t', perl=T)[[1]])[which(Gene.names == gene)]
PUP.source[count] = tmp.pup
}
tmp.pup
length(PUP.source)
PUP.source[145] = 0
length(PUP.source)
file
store.pup = PUP.source
store.pup = PUP.source[1:143]
all_files <- list.files(directory.in)
N.genes <- rep(0, length(all_files))    #Number of genes in each network
PUP.source <- rep(0, length(all_files))  #Posterior probability the gene cis to the eQTL is unaffected
count = 1
for (file in all_files) {
file.path <- paste(directory.in, file, sep="/")
all_data = readLines(file.path)
tissue <- strsplit(all_data[1], split='\t', perl=T)[[1]][2]
n.ind <- as.numeric(strsplit(all_data[2], split='\t', perl=T)[[1]][2])   #Number of independent measurements
chr <- as.numeric(strsplit(all_data[3], split='\t', perl=T)[[1]][2])    #Chromosome number
gene <- strsplit(all_data[4], split='\t', perl=T)[[1]][2]    #Gene of interest
SNP <- strsplit(all_data[5], split='\t', perl=T)[[1]][2]    #eQTL of interest
Gene.names <- strsplit(all_data[6], split='\t', perl=T)[[1]][2:length(strsplit(all_data[6], split='\t', perl=T)[[1]])]   #Column names for Y'Y
n.genes <- length(Gene.names)    #Number of genes in the network
N.genes[count] = n.genes
YtY <- array(NA, dim=c(n.genes, n.genes))   #Y'Y
for (r in 1:n.genes) {
YtY[r,] <- as.numeric(strsplit(all_data[7+r], split='\t', perl=T)[[1]])
}
sxx <- as.numeric(strsplit(all_data[8+n.genes], split='\t', perl=T)[[1]][2])   #X'X, a scalar
YtX <- as.numeric(strsplit(all_data[10+n.genes], split='\t', perl=T)[[1]])    #Y'X, a vector
suff.stat <- list(SYY = YtY/n.ind, sxx = sxx/n.ind, SYX = YtX/n.ind, SY1 = rep(0, n.genes), mu.g = 0)
if (n.genes <= 15) {
n.iter <- 3000
n.burn <- 1000
} else {
if (n.genes <= 25) {
n.iter <- 4000
n.burn <- 2000
} else {
n.iter <- 5000
n.burn <- 2500
}
}
sigma.a <- c(0.1, 0.4)
weights.sigma <- c(1, 1)
out.file = file.path(directory.out, sub("(summary)", '\\1.gibbs', file, perl=T))
if (run_gibbs) {
gibbs <- Gibbs.dir(n.iter, n.burn, suff.stat, which(Gene.names == gene), n.ind, sigma.a, weights.sigma, n.genes-1)
PUP.source[count] = gibbs$post.mean[gibbs$D.ind]
gibbs.mat <- rbind(gibbs$post.mean)
colnames(gibbs.mat) <- Gene.names
write.table(gibbs.mat, out.file, col.names=T, row.names=F, append=F, quote=F, sep="\t")
} else {
gibbs.file = readLines(out.file)
tmp.pup = as.numeric(strsplit(gibbs.file[8], split='\t', perl=T)[[1]])[which(Gene.names == gene)]
PUP.source[count] = tmp.pup
}
print(paste0(as.character(count), " of ", as.character(length(all_files))))
count = count + 1
}
PUP.source - store.pup
jpeg('AnalyzeSummaryData_muscleskeletal80.jpeg')
plot(N.genes, 1-PUP.source, main='Posterior Probability of Source Gene as a Function of Network Size', xlab='Number of Genes in Network', ylab='Posterior Probability Source Gene is Affected by SNP')
dev.off()
jpeg('AnalyzeSummaryData_muscleskeletal80.jpeg', width = 550)
plot(N.genes, 1-PUP.source, main='Posterior Probability of Source Gene as a Function of Network Size', xlab='Number of Genes in Network', ylab='Posterior Probability Source Gene is Affected by SNP')
dev.off()
directory.in <- '../data/cis_summary_data/adiposesubcutaneous/thresh_80'
directory.out <- '../output/cis_summary_data/adiposesubcutaneous/thresh_80'
run_gibbs = FALSE;
all_files <- list.files(directory.in)
N.genes <- rep(0, length(all_files))    #Number of genes in each network
PUP.source <- rep(0, length(all_files))  #Posterior probability the gene cis to the eQTL is unaffected
all.post.probs <- c()   #To be used to generate a ROC plot
count = 1
for (file in all_files) {
file.path <- paste(directory.in, file, sep="/")
all_data = readLines(file.path)
tissue <- strsplit(all_data[1], split='\t', perl=T)[[1]][2]
n.ind <- as.numeric(strsplit(all_data[2], split='\t', perl=T)[[1]][2])   #Number of independent measurements
chr <- as.numeric(strsplit(all_data[3], split='\t', perl=T)[[1]][2])    #Chromosome number
gene <- strsplit(all_data[4], split='\t', perl=T)[[1]][2]    #Gene of interest
SNP <- strsplit(all_data[5], split='\t', perl=T)[[1]][2]    #eQTL of interest
Gene.names <- strsplit(all_data[6], split='\t', perl=T)[[1]][2:length(strsplit(all_data[6], split='\t', perl=T)[[1]])]   #Column names for Y'Y
n.genes <- length(Gene.names)    #Number of genes in the network
N.genes[count] = n.genes
YtY <- array(NA, dim=c(n.genes, n.genes))   #Y'Y
for (r in 1:n.genes) {
YtY[r,] <- as.numeric(strsplit(all_data[7+r], split='\t', perl=T)[[1]])
}
sxx <- as.numeric(strsplit(all_data[8+n.genes], split='\t', perl=T)[[1]][2])   #X'X, a scalar
YtX <- as.numeric(strsplit(all_data[10+n.genes], split='\t', perl=T)[[1]])    #Y'X, a vector
suff.stat <- list(SYY = YtY/n.ind, sxx = sxx/n.ind, SYX = YtX/n.ind, SY1 = rep(0, n.genes), mu.g = 0)
if (n.genes <= 15) {
n.iter <- 3000
n.burn <- 1000
} else {
if (n.genes <= 25) {
n.iter <- 4000
n.burn <- 2000
} else {
n.iter <- 5000
n.burn <- 2500
}
}
sigma.a <- c(0.1, 0.4)
weights.sigma <- c(1, 1)
out.file = file.path(directory.out, sub("(summary)", '\\1.gibbs', file, perl=T))
if (run_gibbs) {
gibbs <- Gibbs.dir(n.iter, n.burn, suff.stat, which(Gene.names == gene), n.ind, sigma.a, weights.sigma, n.genes-1)
PUP.source[count] = gibbs$post.mean[gibbs$D.ind]
gibbs.mat <- rbind(gibbs$post.mean)
colnames(gibbs.mat) <- Gene.names
write.table(gibbs.mat, out.file, col.names=T, row.names=F, append=F, quote=F, sep="\t")
} else {
gibbs.file = readLines(out.file)
tmp.probs <- as.numeric(strsplit(gibbs.file[8], split='\t', perl=T)[[1]])
PUP.source[count] = tmp.probs[which(Gene.names == gene)]
all.post.probs <- c(all.post.probs, tmp.probs)
}
#print(paste0(as.character(count), " of ", as.character(length(all_files))))
count = count + 1
}
warnings()
length(all.post.probs)
all.post.probs <- sort(all.post.probs)   #Posterior prob a gene is NOT a trans eQTL
est.FDR <- rep(0, length(all.post.probs))
est.FDR[1] <- all.post.probs[1]
est.sens <- rep(0, length(all.post.probs))
est.sens[1] <- 1
for (i in 2:length(est.FDR)) {
est.FDR[i] <- ((i-1)*est.FDR[i-1] + all.post.probs[i])/i
}
est.FDR[1:20]
est.FDR[1:100]
est.FDR[1:500]
est.FDR
hist(all.post.probs, breaks=50)
sum(all.post.probs)
sum(all.post.probs)/length(all.post.probs)
est.trans <- sum(1-all.post.probs)   #Expected number of trans genes affected (given the data)
est.trans
all_files <- list.files(directory.in)
N.genes <- rep(0, length(all_files))    #Number of genes in each network
PUP.source <- rep(0, length(all_files))  #Posterior probability the gene cis to the eQTL is unaffected
all.post.probs <- c()   #To be used to generate a ROC plot
count = 1
for (file in all_files) {
file.path <- paste(directory.in, file, sep="/")
all_data = readLines(file.path)
tissue <- strsplit(all_data[1], split='\t', perl=T)[[1]][2]
n.ind <- as.numeric(strsplit(all_data[2], split='\t', perl=T)[[1]][2])   #Number of independent measurements
chr <- as.numeric(strsplit(all_data[3], split='\t', perl=T)[[1]][2])    #Chromosome number
gene <- strsplit(all_data[4], split='\t', perl=T)[[1]][2]    #Gene of interest
SNP <- strsplit(all_data[5], split='\t', perl=T)[[1]][2]    #eQTL of interest
Gene.names <- strsplit(all_data[6], split='\t', perl=T)[[1]][2:length(strsplit(all_data[6], split='\t', perl=T)[[1]])]   #Column names for Y'Y
n.genes <- length(Gene.names)    #Number of genes in the network
N.genes[count] = n.genes
YtY <- array(NA, dim=c(n.genes, n.genes))   #Y'Y
for (r in 1:n.genes) {
YtY[r,] <- as.numeric(strsplit(all_data[7+r], split='\t', perl=T)[[1]])
}
sxx <- as.numeric(strsplit(all_data[8+n.genes], split='\t', perl=T)[[1]][2])   #X'X, a scalar
YtX <- as.numeric(strsplit(all_data[10+n.genes], split='\t', perl=T)[[1]])    #Y'X, a vector
suff.stat <- list(SYY = YtY/n.ind, sxx = sxx/n.ind, SYX = YtX/n.ind, SY1 = rep(0, n.genes), mu.g = 0)
if (n.genes <= 15) {
n.iter <- 3000
n.burn <- 1000
} else {
if (n.genes <= 25) {
n.iter <- 4000
n.burn <- 2000
} else {
n.iter <- 5000
n.burn <- 2500
}
}
sigma.a <- c(0.1, 0.4)
weights.sigma <- c(1, 1)
out.file = file.path(directory.out, sub("(summary)", '\\1.gibbs', file, perl=T))
if (run_gibbs) {
gibbs <- Gibbs.dir(n.iter, n.burn, suff.stat, which(Gene.names == gene), n.ind, sigma.a, weights.sigma, n.genes-1)
PUP.source[count] = gibbs$post.mean[gibbs$D.ind]
gibbs.mat <- rbind(gibbs$post.mean)
colnames(gibbs.mat) <- Gene.names
write.table(gibbs.mat, out.file, col.names=T, row.names=F, append=F, quote=F, sep="\t")
} else {
gibbs.file = readLines(out.file)
tmp.probs <- as.numeric(strsplit(gibbs.file[8], split='\t', perl=T)[[1]])
PUP.source[count] = tmp.probs[which(Gene.names == gene)]
all.post.probs <- c(all.post.probs, tmp.probs[-which(Gene.names == gene)])
}
#print(paste0(as.character(count), " of ", as.character(length(all_files))))
count = count + 1
}
all.post.probs <- sort(all.post.probs)   #Posterior prob a gene is NOT a trans eQTL
est.trans <- sum(1-all.post.probs)   #Expected number of trans genes affected (given the data)
est.FDR <- rep(0, length(all.post.probs))
est.FDR[1] <- all.post.probs[1]
est.sens <- rep(0, length(all.post.probs))
est.sens[1] <- (1 - all.post.probs[1])/est.trans
for (i in 2:length(est.FDR)) {
est.FDR[i] <- ((i-1)*est.FDR[i-1] + all.post.probs[i])/i
est.sens[i] <- est.sens[i-1] + (1 - all.post.probs[i])/est.trans
}
est.sens
plot(est.FDR, est.sens, type="l")
plot(est.FDR, est.sens, type="l", xlim=c(0,1))
lines(seq(max(est.FDR), 1, 100), rep(1, 100))
lines(seq(max(est.FDR), 1, length=100), rep(1, 100))
abline(v=0.05)
plot(est.FDR, est.sens, type="l", main='Estimate ROC Curve for Affected Genes Trans to SNP in Adipose', xlab="Estimated (conditional) False Discovery Rate", ylab='Estimated Sensitivity')
lines(seq(max(est.FDR), 1, length=100), rep(1, 100))
plot(est.FDR, est.sens, type="l", main='Estimate ROC Curve for Affected Genes Trans to SNP in Adipose', xlab="Estimated (conditional) False Discovery Rate", ylab='Estimated Sensitivity', xlim=c(0, max(0.6, est.FDR)))
lines(seq(max(est.FDR), 1, length=100), rep(1, 100))
jpeg('AnalyzeSummaryData_Adipose80_ROC.jpeg', width = 550)
plot(est.FDR, est.sens, type="l", main='Estimate ROC Curve for Affected Genes Trans to SNP in Adipose', xlab="Estimated (conditional) False Discovery Rate", ylab='Estimated Sensitivity', xlim=c(0, max(0.6, est.FDR)))
lines(seq(max(est.FDR), 1, length=100), rep(1, 100))
dev.off()
hist(all.post.probs)
hist(all.post.probs, breaks=30)
hist(1-all.post.probs, breaks=30, xlab="Posterior Probability Gene Trans to SNP is AFFECTED by SNP", ylab="Frequency", main="Histogram of Posterior Probabilities a Trans Gene is AFFECTED by SNP")
hist(1-all.post.probs, breaks=30, xlab="Posterior Probability Gene Trans to SNP is AFFECTED by SNP", ylab="Frequency", main="Histogram of Posterior Probabilities a Trans Gene is AFFECTED by SNP", xlim=c(0,1))
length(all_files)
library('gtools')
source("../R/directionality_CGM.R")
source("../R/SimulateNetworkExpression.R")
source("../R/Model2.R")
path.data <- "../data/raw_expression/skinsunexposedlowerleg_hcp_corrected_factors_genes_certain_biotypes_TPM.txt"
G.raw <- data.frame(read.table(path.data, sep="\t", dec=".", header=T, check.names=T))
n.ind <- ncol(G.raw) - 1    #Number of individuals
p <- nrow(G.raw)        #Number of genes
G.centered <- as.matrix(G.raw[,2:(n.ind+1)]) - cbind( apply(as.matrix(G.raw[,2:(n.ind+1)]), 1, mean) ) %*% rbind( rep(1, n.ind) )
p
p <- 1000
m <- 4    #Minimum number of neighbors
t <- 9    #Maximum number of neighbors
cor.thresh <- 0.8   #Correlation threshold to be considered a neighbor
Network.genes <- list()     #The first index is the anchor gene
Network.Exp <- list()       #Raw gene expression of genes in the network
count <- 1
for (g in 1:p) {
G.g <- G.centered[g,]
corr.g <- G.g %*% t(G.centered) / n.ind
corr.g <- corr.g / corr.g[g]
ind.g <- which(abs(corr.g) >= cor.thresh)
if (length(ind.g) >= m+1) {
ind.g.sorted <- order(-corr.g)[1:min(t+1, length(ind.g))]
Network.genes[[count]] <- ind.g.sorted
Network.Exp[[count]] <- G.centered[ind.g.sorted,]   #an n.nei + 1 x n.ind matrix
count <- count + 1
}
}
n.networks <- count - 1
n.netowrks
n.networks
p <- 5000
m <- 4    #Minimum number of neighbors
t <- 9    #Maximum number of neighbors
cor.thresh <- 0.8   #Correlation threshold to be considered a neighbor
Network.genes <- list()     #The first index is the anchor gene
Network.Exp <- list()       #Raw gene expression of genes in the network
count <- 1
for (g in 1:p) {
G.g <- G.centered[g,]
corr.g <- G.g %*% t(G.centered) / n.ind
corr.g <- corr.g / corr.g[g]
ind.g <- which(abs(corr.g) >= cor.thresh)
if (length(ind.g) >= m+1) {
ind.g.sorted <- order(-corr.g)[1:min(t+1, length(ind.g))]
Network.genes[[count]] <- ind.g.sorted
Network.Exp[[count]] <- G.centered[ind.g.sorted,]   #an n.nei + 1 x n.ind matrix
count <- count + 1
}
}
n.networks <- count - 1
n.networks
theta <- 0.4    #effect size = theta * standard deviation
maf <- 0.1      #minor allele frequency
D <- c(1)    #Direct effect indices
I <- c(2:m)    #Indirect effect indices
lambda <- 0.8        #Shrinkage parameter for indirect effects
n.D <- length(D)
n.I <- length(I)
###Some Parameters for the Gibbs Sampler###
n.iter <- 2000
n.burn <- 1000
theta.gibbs <- c(0.5,0.5,0.5)  #If Dirichlet = T, this is the prior on alpha. Otherwise, this is proportional to the probability of unaffected, indirectly affected, directly affected by the cis-eQTL
Dirichlet <- T
sigma.a <- c(0.2, 0.4, 0.6)        	#Prior sd's on effect; used in BF calculation
weights.sigma <- c(1,1,1)					#Relative weights of each element of sigma.a
ind.net <- 1
net.genes <- Network.genes[[ind.net]]
raw.expr <- Network.Exp[[ind.net]]
n.nei <- nrow(raw.expr) - 1
m.wishart <- n.nei + 1    ##DOF used in Wishart prior in Bayes Factor analysis
U <- ((m+1):(n.nei+1))
n.U <- length(U)
X.genotype <- rbinom(n.ind, 1, maf) + rbinom(n.ind, 1, maf)   #Genotype vector
Sigma.net <- raw.expr %*% t(raw.expr) / n.ind   #Covariance matrix for the simulated network (needed for indirect effects)
Sigma.12 <- Sigma.net[I, c(D, U)]
Sigma.22 <- Sigma.net[c(D, U), c(D, U)]
tmp.vec <- lambda * Sigma.12 %*% cbind( solve(Sigma.22, c(rep(1, n.D), rep(0, n.U))) )
effect.size <- theta * Sigma.net[1,1]    #Effect of genotype at source gene
mu.D <- effect.size * matrix( rep(X.genotype, n.D), nrow=n.D, ncol=n.ind, byrow=T )   #Mean for direct effect
mu.I <- effect.size * lambda * cbind(tmp.vec) %*% rbind(X.genotype)    #Mean for indirect effects
Y.sim <- raw.expr
Y.sim[D,] <- Y.sim[D,] + mu.D
Y.sim[I,] <-  Y.sim[I,] + mu.I   #A (n.nei + 1) x n.ind matrix
suff.stat <- Suff.stat(t(Y.sim), X.genotype)
gibbs.cgm <- Gibbs.dir.cgm(n.iter, n.burn, suff.stat, D[1], n.ind, sigma.a, weights.sigma, theta=theta.gibbs, dirichlet=Dirichlet, update.lambda=F)
names(gibbs.cgm)
gibbs.cgm$post.mean.U
gibbs.cgm$post.mean.I
gibbs.cgm$post.mean.D
gibbs.cgm <- Gibbs.dir.cgm(n.iter, n.burn, suff.stat, D[1], n.ind, sigma.a, weights.sigma, theta=theta.gibbs, dirichlet=Dirichlet, update.lambda=F)
gibbs.cgm$post.mean.U
I
lambda
library('gtools')
source("../R/directionality_CGM.R")
source("../R/SimulateNetworkExpression.R")
source("../R/Model2.R")
gibbs.cgm <- Gibbs.dir.cgm(n.iter, n.burn, suff.stat, D[1], n.ind, sigma.a, weights.sigma, theta=theta.gibbs, dirichlet=Dirichlet, update.lambda=F)
gibbs.cgm
library('gtools')
source("../R/directionality_CGM.R")
source("../R/SimulateNetworkExpression.R")
source("../R/Model2.R")
lambda
Gibbs.dir.cgm.fixedLambda(n.iter, n.burn, suff.stat, D[1], n.ind, sigma.a, weights.sigma, theta=theta.gibbs, dirichlet=Dirichlet, lambda=lambda)
gibbs.cgm <- Gibbs.dir.cgm(n.iter, n.burn, suff.stat, D[1], n.ind, sigma.a, weights.sigma, theta=theta.gibbs, dirichlet=Dirichlet, update.lambda=F)
gibbs.cgm
n.networks
theta <- 0.4    #effect size = theta * standard deviation
maf <- 0.1      #minor allele frequency
D <- c(1)    #Direct effect indices
I <- c(2:m)    #Indirect effect indices
lambda <- 0.8        #Shrinkage parameter for indirect effects
n.D <- length(D)
n.I <- length(I)
###Some Parameters for the Gibbs Sampler###
n.iter <- 2000
n.burn <- 1000
theta.gibbs <- c(0.5,0.5,0.5)  #If Dirichlet = T, this is the prior on alpha. Otherwise, this is proportional to the probability of unaffected, indirectly affected, directly affected by the cis-eQTL
Dirichlet <- T
sigma.a <- c(0.2, 0.4, 0.6)        	#Prior sd's on effect; used in BF calculation
weights.sigma <- c(1,1,1)
SimResults.cgm <- list()     #posterior probability unaffected from CGM's method (condition on Sigma)
for (ind.net in 1:n.networks) {
net.genes <- Network.genes[[ind.net]]
raw.expr <- Network.Exp[[ind.net]]
n.nei <- nrow(raw.expr) - 1
m.wishart <- n.nei + 1    ##DOF used in Wishart prior in Bayes Factor analysis
U <- ((m+1):(n.nei+1))
n.U <- length(U)
X.genotype <- rbinom(n.ind, 1, maf) + rbinom(n.ind, 1, maf)   #Genotype vector
Sigma.net <- raw.expr %*% t(raw.expr) / n.ind   #Covariance matrix for the simulated network (needed for indirect effects)
Sigma.12 <- Sigma.net[I, c(D, U)]
Sigma.22 <- Sigma.net[c(D, U), c(D, U)]
tmp.vec <- lambda * Sigma.12 %*% cbind( solve(Sigma.22, c(rep(1, n.D), rep(0, n.U))) )
effect.size <- theta * Sigma.net[1,1]    #Effect of genotype at source gene
mu.D <- effect.size * matrix( rep(X.genotype, n.D), nrow=n.D, ncol=n.ind, byrow=T )   #Mean for direct effect
mu.I <- effect.size * lambda * cbind(tmp.vec) %*% rbind(X.genotype)    #Mean for indirect effects
Y.sim <- raw.expr
Y.sim[D,] <- Y.sim[D,] + mu.D
Y.sim[I,] <-  Y.sim[I,] + mu.I   #A (n.nei + 1) x n.ind matrix
suff.stat <- Suff.stat(t(Y.sim), X.genotype)
gibbs.cgm <- Gibbs.dir.cgm.fixedLambda(n.iter, n.burn, suff.stat, D[1], n.ind, sigma.a, weights.sigma, theta=theta.gibbs, dirichlet=Dirichlet, lambda=lambda)
SimResults.cgm[[ind.net]] <- gibbs.cgm$post.mean.U
}
post.U.D.cgm <- c()
post.U.I.cgm <- c()
post.U.U.cgm <- c()
for (ind.net in 1:n.networks) {
post.U.cgm <- SimResults.cgm[[ind.net]]
n.nei <- length(post.U.cgm) - 1
U <- ((m+1):(n.nei+1))
n.U <- length(U)
if (n.D > 1) {
post.U.D.cgm <- c(post.U.D.cgm, post.U.cgm[2:n.D])
}
post.U.I.cgm <- c(post.U.I.cgm, post.U.cgm[I])
post.U.U.cgm <- c(post.U.U.cgm, post.U.cgm[U])
all.data.cgm <- c(post.U.D.cgm, post.U.I.cgm, post.U.U.cgm); order.data.cgm <- order(all.data.cgm)   #Posterior probabilities genes are UNAFFECTED by SNP
gene.label.cgm <- c(rep(2, (n.D-1)*n.networks), rep(1, n.I*n.networks), rep(0, length(all.data.cgm) - (n.D-1)*n.networks - n.I*n.networks))[order.data.cgm]
all.data.cgm <- sort(all.data.cgm)
fdr.all.cgm <- Cond.FDR(all.data.cgm)
fdr.labels.all.cgm <- FDR.labels(gene.label.cgm)
sens.all.cgm <- Sens.labels(gene.label.cgm)
plot(fdr.all.cgm, fdr.labels.all.cgm, xlab="Conditional False Discovery Rate From Gibbs Sampler", ylab="True False Discovery Rate", main="False Discovery Rate in CGM's Method", type="l")
abline(a=0,b=1, col="red")
plot(fdr.labels.all.cgm, sens.all.cgm, xlab="True False Discovery Rate", ylab="Sensitivity = Fraction of Indirect and Directly Affected Genes Captured", main="ROC Plot for CGM's Method", type="l")
hist(1 - post.U.I.cgm, xlab="Posterior Probability Gene is Affected by SNP", main="Indirect Effect Sensitivity in CGM's Method")
}
n.D
n.I
length(all.data.cgm)
length(all.data.cgm) - (n.D-1)*n.networks - n.I*n.networks)
length(all.data.cgm) - (n.D-1)*n.networks - n.I*n.networks
all.data.cgm
post.U.D.cgm
post.U.I.cgm
post.U.U.cgm
all.data.cgm <- c(post.U.D.cgm, post.U.I.cgm, post.U.U.cgm)
all.data.cgm
rep(2, (n.D-1)*n.networks)
rep(0, length(all.data.cgm) - (n.D-1)*n.networks
)
n.I*n.networks
n.I
n.I
post.U.D.cgm <- c()
post.U.I.cgm <- c()
post.U.U.cgm <- c()
for (ind.net in 1:n.networks) {
post.U.cgm <- SimResults.cgm[[ind.net]]
n.nei <- length(post.U.cgm) - 1
U <- ((m+1):(n.nei+1))
n.U <- length(U)
if (n.D > 1) {
post.U.D.cgm <- c(post.U.D.cgm, post.U.cgm[2:n.D])
}
post.U.I.cgm <- c(post.U.I.cgm, post.U.cgm[I])
post.U.U.cgm <- c(post.U.U.cgm, post.U.cgm[U])
}
all.data.cgm <- c(post.U.D.cgm, post.U.I.cgm, post.U.U.cgm); order.data.cgm <- order(all.data.cgm)   #Posterior probabilities genes are UNAFFECTED by SNP
gene.label.cgm <- c(rep(2, (n.D-1)*n.networks), rep(1, n.I*n.networks), rep(0, length(all.data.cgm) - (n.D-1)*n.networks - n.I*n.networks))[order.data.cgm]
all.data.cgm <- sort(all.data.cgm)
fdr.all.cgm <- Cond.FDR(all.data.cgm)
fdr.labels.all.cgm <- FDR.labels(gene.label.cgm)
sens.all.cgm <- Sens.labels(gene.label.cgm)
plot(fdr.all.cgm, fdr.labels.all.cgm, xlab="Conditional False Discovery Rate From Gibbs Sampler", ylab="True False Discovery Rate", main="False Discovery Rate in CGM's Method", type="l")
abline(a=0,b=1, col="red")
plot(fdr.labels.all.cgm, sens.all.cgm, xlab="True False Discovery Rate", ylab="Sensitivity = Fraction of Indirect and Directly Affected Genes Captured", main="ROC Plot for CGM's Method", type="l")
hist(1 - post.U.I.cgm, xlab="Posterior Probability Gene is Affected by SNP", main="Indirect Effect Sensitivity in CGM's Method")
post.U.D.cgm <- c()
post.U.I.cgm <- c()
post.U.U.cgm <- c()
for (ind.net in 1:n.networks) {
post.U.cgm <- SimResults.cgm[[ind.net]]
n.nei <- length(post.U.cgm) - 1
U <- ((m+1):(n.nei+1))
n.U <- length(U)
if (n.D > 1) {
post.U.D.cgm <- c(post.U.D.cgm, post.U.cgm[2:n.D])
}
post.U.I.cgm <- c(post.U.I.cgm, post.U.cgm[I])
post.U.U.cgm <- c(post.U.U.cgm, post.U.cgm[U])
}
all.data.cgm <- c(post.U.D.cgm, post.U.I.cgm, post.U.U.cgm); order.data.cgm <- order(all.data.cgm)   #Posterior probabilities genes are UNAFFECTED by SNP
gene.label.cgm <- c(rep(2, (n.D-1)*n.networks), rep(1, n.I*n.networks), rep(0, length(all.data.cgm) - (n.D-1)*n.networks - n.I*n.networks))[order.data.cgm]
all.data.cgm <- sort(all.data.cgm)
fdr.all.cgm <- Cond.FDR(all.data.cgm)
fdr.labels.all.cgm <- FDR.labels(gene.label.cgm)
sens.all.cgm <- Sens.labels(gene.label.cgm)
plot(fdr.all.cgm, fdr.labels.all.cgm, xlab="Conditional False Discovery Rate From Gibbs Sampler", ylab="True False Discovery Rate", main="False Discovery Rate in CGM's Method", type="l")
abline(a=0,b=1, col="red")
plot(fdr.labels.all.cgm, sens.all.cgm, xlab="True False Discovery Rate", ylab="Sensitivity = Fraction of Indirect and Directly Affected Genes Captured", main="ROC Plot for CGM's Method", type="l")
hist(1 - post.U.I.cgm, xlab="Posterior Probability Gene is Affected by SNP", main="Indirect Effect Sensitivity in CGM's Method")
